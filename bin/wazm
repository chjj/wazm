#!/usr/bin/env node

/*!
 * wazm - wrapper for emcc
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/wazm
 */

'use strict';

const assert = require('assert');
const fs = require('fs');
const path = require('path');
const url = require('url');
const build = require('../lib/build');

/*
 * Constants
 */

const VERSION = '0.0.0';

const HELP = `
  Usage: wazm [options] [config?]

  Options:

    -h, --help                 output usage information
    -v, --version              output the version number
    -r, --root <path>          root directory (default: cwd)
    -o, --output <file>        output file (default: out.wasm)
    -x, --executable           output executable binary (i.e. a non-library)
    -b, --base64               output as base64 module
    -w, --wat                  output an accompanying .wat file
    -e, --export <symbol>      export symbol
    -m, --initial-memory <mem> initial memory (in pages) (default: 3)
    -S, --total-stack <mem>    total stack (in pages) (default: 1)
    -M, --max-memory <mem>     total stack (in pages) (default: null)
    -g, --grow                 allow heap growth
    -O[x]                      optimization level
    -s <OPTION=VALUE>          pass flag to emcc
    -- <args>                  pass remaining args to emcc
`;

/*
 * Main
 */

async function main(argv) {
  const args = getArgs(argv);

  const options = {
    root: null,
    target: null,
    executable: null,
    base64: null,
    wat: null,
    sources: [],
    exports: [],
    memory: {
      initial: null,
      stack: null,
      max: null,
      grow: null
    },
    flags: [],
    settings: []
  };

  for (let i = 2; i < args.length; i++) {
    const arg = args[i];

    let next = '';

    if (i + 1 < args.length)
      next = args[i + 1];

    switch (arg) {
      case '-v':
      case '--version': {
        process.stdout.write(VERSION + '\n');
        process.exit(0);
        break;
      }

      case '-h':
      case '--help': {
        process.stdout.write(HELP + '\n');
        process.exit(0);
        break;
      }

      case '-r':
      case '--root': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.root = next;
        i += 1;

        break;
      }

      case '-o':
      case '--output': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.target = next;
        i += 1;

        break;
      }

      case '-x':
      case '--executable': {
        options.executable = true;
        break;
      }

      case '-b':
      case '--base64': {
        options.base64 = true;
        break;
      }

      case '-w':
      case '--wat': {
        options.wat = true;
        break;
      }

      case '-e':
      case '--export': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.exports(...next.split(','));
        i += 1;

        break;
      }

      case '-m':
      case '--initial-memory': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.memory.initial = next >>> 0;
        i += 1;
        break;
      }

      case '-S':
      case '--total-stack': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.memory.stack = next >>> 0;
        i += 1;
        break;
      }

      case '-M':
      case '--max-memory': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.memory.max = next >>> 0;
        i += 1;
        break;
      }

      case '-g':
      case '--grow': {
        options.memory.grow = true;
        break;
      }

      case '-O0':
      case '-O1':
      case '-O2':
      case '-O3':
      case '-Os':
      case '-Oz': {
        options.flags.push(arg);
        break;
      }

      case '-s': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.settings.push(next);
        i += 1;
        break;
      }

      case '--': {
        options.flags.push(...args.slice(i + 1));
        i = args.length;
        break;
      }

      default: {
        options.sources.push(arg);
        break;
      }
    }
  }

  if (options.sources.length === 1) {
    const file = path.resolve(options.sources[0]);
    const ext = path.extname(file);

    if (ext === '.json') {
      const text = fs.readFileSync(file, 'utf8');
      const json = JSON.parse(text);

      options.sources.length = 0;

      return build(mergeAll(json, options));
    }

    if (ext === '.js' || ext === '.mjs' || ext === '.cjs') {
      let json = null;

      try {
        const imports = new Function('file', 'return import(file);');
        const mod = await imports(url.pathToFileURL(file));
        json = mod['default'] || mod;
      } catch (e) {
        json = require(file);
      }

      options.sources.length = 0;

      return build(mergeAll(json, options));
    }
  }

  return build(options);
}

/*
 * Helpers
 */

function mergeAll(items, options) {
  const out = [];

  if (!Array.isArray(items))
    items = [items];

  for (const item of items)
    out.push(mergeOptions(item, options));

  return out;
}

function mergeOptions(json, options) {
  json = merge(json, options);

  if (json != null) {
    json.memory = merge(json.memory, options.memory);

    if (Array.isArray(json.sources))
      json.sources = [...json.sources, ...options.sources];

    if (Array.isArray(json.exports))
      json.exports = [...json.exports, ...options.exports];

    if (Array.isArray(json.settings))
      json.settings = [...json.settings, ...options.settings];

    if (Array.isArray(json.flags))
      json.flags = [...json.flags, ...options.flags];
  }

  return json;
}

function merge(out, ...args) {
  if (out == null || typeof out !== 'object')
    out = {};

  out = Object.assign({}, out);

  for (const obj of args) {
    if (obj == null || typeof obj !== 'object')
      continue;

    const keys = Object.keys(obj);

    for (const key of keys) {
      if (obj[key] != null && typeof obj[key] !== 'object')
        out[key] = obj[key];
    }
  }

  return out;
}

function getArgs(argv) {
  assert(Array.isArray(argv));

  const args = [];

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    assert(typeof arg === 'string');

    if (arg.startsWith('--')) {
      // e.g. --opt
      const index = arg.indexOf('=');
      if (index !== -1) {
        // e.g. --opt=val
        args.push(arg.substring(0, index));
        args.push(arg.substring(index + 1));
      } else {
        args.push(arg);
      }
    } else if (arg.startsWith('-')) {
      if (arg.length > 2) {
        // e.g. -abc
        for (let j = 1; j < arg.length; j++)
          args.push(`-${arg.charAt(j)}`);
      } else {
        // e.g. -a
        args.push(arg);
      }
    } else {
      // e.g. foo
      args.push(arg);
    }
  }

  return args;
}

/*
 * Execute
 */

main(process.argv).catch((err) => {
  process.stderr.write(err.stack + '\n');
  process.exit(1);
});
